# 开发扫盲指南（后端篇）

> 面向对后端经验不足的同学，帮助快速理解“后端在做什么”“我们为什么要这样设计”和“下一步怎么配合研发”。

---

## 1. 后端的角色与价值

- **业务大脑**：接收前端发起的操作（登录、提交表单、查看列表等），执行业务规则，维护数据的一致性与流程状态。
- **数据仓库**：负责把所有核心数据（用户、组织、课程、培训计划、考试、证书、通知等）可靠地存入数据库，并支持查询分析。
- **规则执行者**：封装审批链、学习进度计算、提醒策略等复杂逻辑，前端只负责展示与触发。
- **系统整合点**：统一对接短信/邮件、监管平台、对象存储、身份认证等外部服务，形成端到端的闭环。

如果把系统比喻成一座工厂：前端是“大厅和展示柜”，而后端就是“生产车间 + 仓库 + 调度中心”，保障业务真正落地运行。

---

## 2. 我们的后端框架：NestJS 模块化单体

- **语言统一**：使用 TypeScript（与前端一致），降低沟通与维护成本。
- **架构模式**：NestJS = 模块化 + 控制器（Controller）+ 服务（Service）+ 依赖注入（DI），结构清晰、可测试。
- **核心组件**  
  - Controller：定义接口路由（如 `/api/v1/plans`）。  
  - Service：编写业务逻辑（如计划审批、学员进度统计）。  
  - Module：把相关 Controller/Service 组织在一起，形成独立业务域，后续可平滑拆分。  
  - Pipe/Guard/Filter：输入验证、权限控制、异常处理等横切能力。
- **项目结构概览**

```
backend/
├── src/
│   ├── main.ts          # 应用入口，注册配置、全局验证
│   ├── app.module.ts    # 顶层模块，汇聚所有业务模块
│   ├── config/          # 全局配置（环境变量、默认值）
│   └── modules/         # 领域模块（auth、training-plan、notification 等）
└── libs/                # 公共库（实体、工具、领域事件等）
```

- **为什么称为“模块化单体”**：当前仍部署为一个应用（单体），但内部按领域清晰划分模块、通过接口/事件交互。未来业务复杂时，可以低成本拆成独立服务（微服务化）。

---

## 3. 接口设计方法

我们采用 RESTful 风格，核心原则如下：

1. **统一前缀与版本**：所有接口走 `/api/v1/...`，便于版本管理与网关治理。
2. **动词与方法对应**：  
   - `GET`：查询  
   - `POST`：创建  
   - `PUT/PATCH`：更新  
   - `DELETE`：删除或标记停用
3. **资源化命名**：以业务对象命名。例如：  
   - 培训计划 → `/plans`  
   - 学员任务 → `/assignments`  
   - 消息中心 → `/notifications`
4. **鉴权统一**：除登录外，所有请求头带 `Authorization: Bearer <access_token>`；服务端校验用户身份、角色、租户，执行 RBAC。
5. **响应格式**：统一 `{ code, message, data, traceId }`，错误码区分业务异常/系统异常。
6. **分页与筛选**：标准参数 `page`, `pageSize`, `status`, `keyword`, `startTime`, `endTime` 等，前端可以复用组件。
7. **错误码约定（举例）**：  
   - `1000`：成功  
   - `2001`：账号或密码错误  
   - `2403`：无访问权限  
   - `2601`：计划状态不允许当前操作  
   - `2999`：业务通用错误  
   - `5000`：系统内部错误

> 已在 `backend/docs/api-plan.md` 输出首批重点模块（认证、培训计划、消息中心）的接口清单，可作为开发对照表。

---

## 4. 数据库设计思路

- **数据库**：MySQL 8（建议使用云 RDS），满足事务、统计、备份需求。
- **多租户隔离**：所有核心表包含 `tenant_id` 字段，配合索引实现逻辑隔离。
- **主键策略**：全面使用 UUID，防止 ID 泄露业务规模，易于数据迁移。
- **核心表举例**：
  - `tenant`：租户信息、套餐、状态。
  - `user` / `user_profile`：账号、岗位、个人档案、审核状态。
  - `training_plan`、`plan_course`、`plan_target_role`：计划定义、关联课程与适用岗位。
  - `training_assignment`：学员任务记录，包含进度、状态、最后学习时间。
  - `exam`、`exam_session`、`exam_answer_sheet`：考试与答题记录。
  - `certificate_template`、`certificate_instance`：证书模板与个人证书。
  - `notification_*`：消息模板、发送任务、用户阅读状态。
- **公共字段**：所有表包含 `created_at`, `updated_at`, `created_by`, `updated_by`, `is_deleted`，便于审计与软删除。
- **性能与扩展**：对高频查询字段建索引，学习记录/通知日志按时间或租户分区，热点数据放 Redis 缓存。

---

## 5. 部署与运维全流程

1. **环境划分**  
   - DEV（开发自测）  
   - TEST（功能与回归测试）  
   - STAGING/UAT（预发布，模拟生产配置）  
   - PROD（正式环境）

2. **容器化与发布**  
   - 代码构建为 Docker 镜像，部署到 Kubernetes/云容器服务。  
   - 按模块设置 Deployment，支持弹性扩容与滚动更新。  
   - 使用 CI/CD（GitLab CI/GitHub Actions）串联编译、测试、镜像构建、部署审批，确保每次上线可追溯、可回滚。

3. **配置管理**  
   - 环境变量或配置中心（如 `@nestjs/config`、Nacos、Apollo）管理敏感信息。  
   - 不同环境使用不同的数据库、对象存储、消息队列配置。

4. **基础设施对接**  
   - 数据库：MySQL 主从或多 AZ，定期备份、开启审计。  
   - 缓存：Redis（验证码、会话、热点数据）。  
   - 对象存储：OSS/S3，存课件、证书附件，配合 CDN 加速与防盗链。  
   - 消息网关：短信/邮件/推送服务。

5. **监控与日志**  
   - 监控：Prometheus + Grafana（CPU、内存、接口耗时、错误率）。  
   - 日志：ELK / Loki / 云日志服务，按租户、请求追踪（traceId）。  
   - 链路追踪：可引入 OpenTelemetry，定位跨服务问题。

6. **安全治理**  
   - HTTPS 全站加密，WAF 防火墙，接口限流。  
   - 密码加密存储、Token 鉴权、操作审计。  
   - 定期安全扫描与漏洞修复，建立异常响应流程。

---

## 6. 和前端如何配合？

1. **需求澄清**：先明确前端页面所需数据、交互流程、异常场景。  
2. **接口对齐**：利用接口规划文档/Swagger/Apifox 约定字段与错误处理。  
3. **Mock & 联调**：前端可用 Mock Server 自测，后端准备测试环境数据，联调阶段聚焦边界与性能。  
4. **回归验证**：上线前全链路回归（前端 UI + 后端接口 + 数据库状态 + 通知触发）。

前端+后端协同，就是“一个对用户、业务负责的整体团队”。前端理解后端的职责和实现方式，能更好地提出合理的需求；后端了解前端的展示场景，也能更贴近用户体验设计接口与数据结构。

---

## 7. 下一步做什么？

- **继续模块化拆分**：在 `src/modules/` 下逐步实现 `auth`、`training-plan`、`notification` 等模块。
- **接入数据库层**：选择 Prisma 或 TypeORM，编写实体与迁移脚本。
- **补充自动化测试**：Controller/Service 单测 + 接口集成测试，保障后续重构稳定。
- **完善文档**：Swagger 自动生成 API 文档，配合 `docs/api-plan.md` 持续迭代。

只要理解了以上框架，后续无论是实现新接口、排查线上问题，还是规划微服务演进路线，都能胸有成竹。欢迎随时提出具体问题，我们可以继续深入到模块实现与数据库建模的细节。

